module.exports = Test

var Readable = require('stream').Readable
/* istanbul ignore if */
if (!Readable || process.version.match(/^v0\.10/)) {
  Readable = require('readable-stream').Readable
}

var Promise = require('bluebird')

function Deferred () {
  this.resolve = null
  this.reject = null
  this.promise = new Promise(function (resolve, reject) {
    this.reject = reject
    this.resolve = resolve
  }.bind(this))
}

var util = require('util')
util.inherits(Test, Readable)

// A sigil object for implicit end() calls that should not
// trigger an error if the user then calls t.end()
var IMPLICIT = {}

var yaml = require('js-yaml')
var stack = require('./stack.js')
var tapAsserts = require('./assert.js')
var assert = require('assert')
var spawn = require('child_process').spawn
var Parser = require('tap-parser')
var path = require('path')
var Module = require('module').Module
var fs = require('fs')
var cleanYamlObject = require('clean-yaml-object')
var binpath = path.resolve(__dirname, '../bin')

function hasOwn (obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key)
}

function Test (options) {
  options = options || {}

  if (!(this instanceof Test)) {
    return new Test(options)
  }

  this.assertStack = null
  this.assertAt = null

  this._deferred = null
  this._autoend = !!options.autoend
  this._name = options.name || '(unnamed test)'
  this._ok = true
  this._pass = 0
  this._fail = 0
  this._skip = 0
  this._todo = 0
  this._count = 0
  this._bailedOut = false
  this._endEmitted = false
  this._explicitEnded = false
  this._multiEndThrew = false
  this._ranAfterEach = false

  if (Object.prototype.hasOwnProperty.call(options, 'bail')) {
    this._bail = !!options.bail
  } else {
    this._bail = process.env.TAP_BAIL === '1'
  }

  this._passes = []
  this._fails = []
  this._skips = []
  this._todos = []

  this._beforeEach = []
  this._afterEach = []

  this._plan = -1
  this._queue = []
  this._currentChild = null
  this._ending = false
  this._ended = false
  this._mustDeferEnd = false
  this._deferredEnd = null

  this._parent = null
  this._printedVersion = false

  this._startTime = process.hrtime()
  this._calledAt = options.at || stack.at(this.test)
  if (!this._calledAt || !this._calledAt.file) {
    this._calledAt = stack.at(Test)
  }

  this._timer = null
  this._timeout = 0
  if (options.timeout !== Infinity &&
    !isNaN(options.timeout) &&
    options.timeout > 0) {
    this.setTimeout(options.timeout)
  }

  Readable.apply(this, options)

  // Bind all methods.
  var bound = {}
  for (var m in this) {
    if (typeof this[m] === 'function') {
      this[m] = this[m].bind(this)
      bound[m] = true
    }
  }
  Object.getOwnPropertyNames(Test.prototype).forEach(function (name) {
    if (typeof this[name] === 'function' && !bound[name]) {
      Object.defineProperty(this, name, {
        value: this[name].bind(this),
        enumerable: false,
        configurable: true,
        writable: true
      })
    }
  }, this)
}

Test.prototype.tearDown = Test.prototype.teardown = function (fn) {
  this.on('end', fn)
}

Test.prototype.setTimeout = function (n) {
  if (n === Infinity) {
    if (this._timer) {
      clearTimeout(this._timer)
      this._timer = null
    }
    this._timeout = 0
    return
  }

  if (isNaN(n) || n <= 0) {
    throw new TypeError('setTimeout: number > 0 required')
  }

  this._timeout = n
  if (this._timer) {
    clearTimeout(this._timer)
  }

  var self = this
  this._timer = setTimeout(function () {
    self._onTimeout()
  }, n)
}

Test.prototype._onTimeout = function (extra) {
  clearTimeout(this._timer)
  this._timer = null
  // anything that was pending will have to wait.
  var s = this
  while (s._currentChild && (s._currentChild instanceof Test)) {
    s._queue = []
    s.end(IMPLICIT)
    s = s._currentChild
  }

  extra = extra || {}
  if (this._parent) {
    extra.expired = this._name
  }
  if (this._timeout) {
    extra.timeout = this._timeout
  }
  extra.at = this._calledAt
  s.fail('timeout!', extra)
  s.end(IMPLICIT)

  this.endAll()
}

// Called when endAll() is fired and there's stuff in the queue
Test.prototype._queueFail = function () {
  var queue = this._queue
  this._queue = []

  queue.forEach(function (q) {
    var what = q[0]
    var msg = what + ' left in queue'
    var extra = { at: this._calledAt }

    switch (what) {
      case 'test':
        extra = q[2]
        msg = 'child test left in queue: ' + (q[1] || '(unnamed)')
        break

      case 'printResult':
        if (q[2] === 'test unfinished: ' + (this._name || '(unnamed)')) {
          return
        }
        msg = (q[1] ? 'ok' : 'not ok') + ' - ' + q[2].trim()
        msg = 'test point left in queue: ' + msg
        extra = q[3]
        extra.at = extra.at || null
        break

      case 'spawn':
        extra = q[5]
        extra.command = q[1]
        extra.args = q[2]
        extra.options = q[3]
        msg = 'spawn left in queue: ' + (q[4] || '(unnamed)')
        break

      case 'end':
        return
    }

    if (this._parent) {
      extra.test = this._name
    }

    this.fail(msg, extra)
  }, this)
}

Test.prototype.endAll = function () {
  var child = this._currentChild

  if (this._queue && this._queue.length) {
    this._queueFail()
  }

  if (child) {
    if (!child._ended && child.fail) {
      var msg = 'test unfinished: ' + (child._name || '(unnamed)')
      var extra = { at: child._calledAt }
      if (child._plan !== -1) {
        extra.plan = child._plan
        extra.count = child._count
      }
      child.fail(msg, extra)
    }

    if (child.end) {
      child.end(IMPLICIT)
    }

    if (child.endAll) {
      child.endAll()
    }

    if (child.kill) {
      child.kill('SIGTERM')
    }

    child._bailedOut = true
  }

  this.end(IMPLICIT)
}

Test.prototype._extraFromError = function (er, extra) {
  extra = extra || {}
  if (!er || typeof er !== 'object') {
    extra.error = er
    return extra
  }

  var message = er.message
  var addName = true

  if (!message && er.stack) {
    message = er.stack.split('\n')[0]
    addName = false
  }

  er.message = ''
  var st = er.stack
  if (st) {
    st = st.split('\n')
    // parse out the 'at' bit from the first line.
    extra.at = stack.parseLine(st[1])
    extra.stack = stack.clean(st)
  }
  er.message = message

  if (addName && er.name) {
    message = er.name + ': ' + message
  }

  Object.keys(er).forEach(function (k) {
    if (k === 'message') {
      return
    }
    extra[k] = er[k]
  })

  extra.message = message

  return extra
}

Test.prototype.threw = function threw (er, extra, proxy) {
  this._ok = false
  this._threw = this._threw || er

  if (this._name && !proxy) {
    er.test = this._name
  }

  // If we've already ended, then try to pass this up the chain
  // Presumably, eventually the root harness will catch it and
  // deal with it, since that only ends on process exit.
  if (this._ended) {
    if (this._parent) {
      return this._parent.threw(er, extra, true)
    } else {
      throw er
    }
  }

  if (!extra) {
    extra = this._extraFromError(er)
  }

  this.fail(extra.message || er.message, extra)

  // thrown errors cut to the front of the queue.
  if (this._currentChild && this._queue.length) {
    this._queue.unshift(this._queue.pop())
  }
  if (!proxy) {
    this.end(IMPLICIT)
  }
}

Test.prototype.pragma = function (set) {
  if (this._bailedOut) {
    return
  }

  if (this._currentChild) {
    this._queue.push(['pragma', set])
    return
  }

  for (var i in set) {
    this.push('pragma ' + (set[i] ? '+' : '-') + i + '\n')
  }
}

Test.prototype.plan = function (n, comment) {
  if (this._bailedOut) {
    return
  }

  if (this._currentChild) {
    this._queue.push(['plan', n, comment])
    return
  }

  if (this._plan !== -1) {
    throw new Error('Cannot set plan more than once')
  }

  if (typeof n !== 'number' || n < 0) {
    throw new TypeError('plan must be a number')
  }

  // Cannot get any tests after a trailing plan, or a plan of 0
  var ending = false
  if (this._count !== 0 || n === 0) {
    ending = true
  }

  this._plan = n
  comment = comment ? ' # ' + comment.trim() : ''
  this.push('1..' + n + comment + '\n')

  if (ending) {
    this.end(IMPLICIT)
  }
}

Test.prototype._parseTestArgs = function (name, extra, cb) {
  if (typeof name === 'function') {
    cb = name
    name = ''
    extra = {}
  } else if (typeof name === 'object') {
    cb = extra
    extra = name
    name = ''
  } else if (typeof extra === 'function') {
    cb = extra
    extra = {}
  }

  if (!extra) {
    extra = {}
  }

  if (!cb) {
    extra.todo = true
  } else if (typeof cb !== 'function') {
    t