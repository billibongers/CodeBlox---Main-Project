'use strict';

var legacyLog = require('../');
var Log = legacyLog.Log;

// Helper for testing stdout
var hooker = require('hooker');
function stdoutEqual(test, callback, expected) {
  var actual = '';
  // Hook process.stdout.write
  hooker.hook(process.stdout, 'write', {
    // This gets executed before the original process.stdout.write.
    pre: function(result) {
      // Concatenate uncolored result onto actual.
      actual += result;
      // Prevent the original process.stdout.write from executing.
      return hooker.preempt();
    },
  });
  // Execute the logging code to be tested.
  callback();
  // Restore process.stdout.write to its original value.
  stdoutUnmute();
  // Actually test the actually-logged stdout string to the expected value.
  // test.equal(legacyLog.uncolor(actual), expected);
  test.equal(actual, expected);
}

// Outright mute stdout.
function stdoutMute() {
  hooker.hook(process.stdout, 'write', {
    pre: function() {
      return hooker.preempt();
    },
  });
}

// Unmute stdout.
function stdoutUnmute() {
  hooker.unhook(process.stdout, 'write');
}

// Helper function: repeat('a', 3) -> 'aaa', repeat('a', 3, '-') -> 'a-a-a'
function repeat(str, n, separator) {
  var result = str;
  for (var i = 1; i < n; i++) {
    result += (separator || '') + str;
  }
  return result;
}

var fooBuffer = new Buffer('foo');

exports['Log instance'] = {
  setUp: function(done) {
    this.grunt = {fail: {errorcount: 0}};
    done();
  },
  'write': function(test) {
    test.expect(4);
    var log = new Log();

    stdoutEqual(test, function() { log.write(''); }, '');
    stdoutEqual(test, function() { log.write('foo'); }, 'foo');
    stdoutEqual(test, function() { log.write('%s', 'foo'); }, 'foo');
    stdoutEqual(test, function() { log.write(fooBuffer); }, 'foo');

    test.done();
  },
  'writeln': function(test) {
    test.expect(4);
    var log = new Log();

    stdoutEqual(test, function() { log.writeln(); }, '\n');
    stdoutEqual(test, function() { log.writeln('foo'); }, 'foo\n');
    stdo