// Generated by CoffeeScript 2.0.0-beta7
void function () {
  var cache$, construct, eq, Expression, FunctionExpression, Getter, Identifier, IdentifierName, Key, listOf, Node, nubBy, Number_, ObjectExpression, oneOf, Property, propName, Setter, String_;
  Node = require('../node');
  Expression = require('../classes/Expression');
  FunctionExpression = require('./FunctionExpression');
  IdentifierName = require('./IdentifierName');
  Identifier = require('./Identifier');
  Number_ = require('./Number');
  String_ = require('./String');
  cache$ = require('../combinators');
  construct = cache$.construct;
  oneOf = cache$.oneOf;
  listOf = cache$.listOf;
  nubBy = function (xs, eq) {
    return function (accum$) {
      var x;
      for (var i$ = 0, length$ = xs.length; i$ < length$; ++i$) {
        x = xs[i$];
        if (!!function (accum$1) {
            var y;
            for (var i$1 = 0, length$1 = xs.length; i$1 < length$1; ++i$1) {
              y = xs[i$1];
              if (!eq(x, y))
                continue;
              accum$1.push(y);
            }
            return accum$1;
          }.call(this, []).length)
          continue;
        accum$.push(x);
      }
      return accum$;
    }.call(this, []);
  };
  propName = function (node) {
    switch (node.type) {
    case 'Literal':
      return '' + node.value;
    case 'Identifier':
      return node.name;
    }
  };
  eq = function (x, y) {
    return propName(x) === propName(y) && (x.kind === y.kind && (x.kind === 'get' || x.kind === 'set') || x.kind === 'init' && (y.kind === 'get' || y.kind === 'set') || y.kind === 'init' && (x.kind === 'get' || x.kind === 'set'));
  };
  Key = oneOf([
    String_,
    Number_,
    IdentifierName
  ]);
  Property = function () {
    return {
      kind: 'init',
      key: Key.apply(null, [].slice.call(arguments).concat()),
      value: Expression.apply(null, [].slice.call(arguments).concat())
    };
  };
  Getter = function () {
    var fn;
    fn = FunctionExpression.apply(null, [].slice.call(arguments).concat());
    fn.params.length = 0;
    return {
      kind: 'get',
      key: Key.apply(null, [].slice.call(arguments).concat()),
      value: fn
    };
  };
  Setter = function () {
    var fn;
    fn = FunctionExpression.apply(null, [].slice.call(arguments).concat());
    fn.params = [Identifier.apply(null, [].slice.call(arguments).concat())];
    return {
      kind: 'set',
      key: Key.apply(null, [].slice.call(arguments).concat()),
      value: fn
    };
  };
  ObjectExpression = function (super$) {
    extends$(ObjectExpression, super$);
    ObjectExpression.prototype.type = ObjectExpression.name;
    ObjectExpression.prototype.properties = [];
    function ObjectExpression(depth, ancestors) {
      --depth;
      if (depth > 0) {
        ancestors = [this].concat(ancestors);
        this.properties = nubBy(listOf([
          Property,
          Getter,
          Setter
        ])(depth, ancestors), eq);
      }
    }
    return ObjectExpression;
  }(Node);
  module.exports = construct(ObjectExpression);
  function isOwn$(o, p) {
    return {}.hasOwnProperty.call(o, p);
  }
  function extends$(child, parent) {
    for (var key in parent)
      if (isOwn$(parent, key))
        child[key] = parent[key];
    function ctor() {
      this.constructor = child;
    }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor;
    child.__super__ = parent.prototype;
    return child;
  }
}.call(this);
