/* Silly noise to be able to load in source code without doing an XMLHttpReq */var jquery164 = "/*!\n\
 * jQuery JavaScript Library v1.6.4\n\
 * http://jquery.com/\n\
 *\n\
 * Copyright 2011, John Resig\n\
 * Dual licensed under the MIT or GPL Version 2 licenses.\n\
 * http://jquery.org/license\n\
 *\n\
 * Includes Sizzle.js\n\
 * http://sizzlejs.com/\n\
 * Copyright 2011, The Dojo Foundation\n\
 * Released under the MIT, BSD, and GPL Licenses.\n\
 *\n\
 * Date: Mon Sep 12 18:54:48 2011 -0400\n\
 */\n\
(function( window, undefined ) {\n\
\n\
// Use the correct document accordingly with window argument (sandbox)\n\
var document = window.document,\n\
	navigator = window.navigator,\n\
	location = window.location;\n\
var jQuery = (function() {\n\
\n\
// Define a local copy of jQuery\n\
var jQuery = function( selector, context ) {\n\
		// The jQuery object is actually just the init constructor 'enhanced'\n\
		return new jQuery.fn.init( selector, context, rootjQuery );\n\
	},\n\
\n\
	// Map over jQuery in case of overwrite\n\
	_jQuery = window.jQuery,\n\
\n\
	// Map over the $ in case of overwrite\n\
	_$ = window.$,\n\
\n\
	// A central reference to the root jQuery(document)\n\
	rootjQuery,\n\
\n\
	// A simple way to check for HTML strings or ID strings\n\
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\
	quickExpr = /^(?:[^#<]*(<[\\w\\W]+>)[^>]*$|#([\\w\\-]*)$)/,\n\
\n\
	// Check if a string has a non-whitespace character in it\n\
	rnotwhite = /\\S/,\n\
\n\
	// Used for trimming whitespace\n\
	trimLeft = /^\\s+/,\n\
	trimRight = /\\s+$/,\n\
\n\
	// Check for digits\n\
	rdigit = /\\d/,\n\
\n\
	// Match a standalone tag\n\
	rsingleTag = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>)?$/,\n\
\n\
	// JSON RegExp\n\
	rvalidchars = /^[\\],:{}\\s]*$/,\n\
	rvalidescape = /\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g,\n\
	rvalidtokens = /\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g,\n\
	rvalidbraces = /(?:^|:|,)(?:\\s*\\[)+/g,\n\
\n\
	// Useragent RegExp\n\
	rwebkit = /(webkit)[ \\/]([\\w.]+)/,\n\
	ropera = /(opera)(?:.*version)?[ \\/]([\\w.]+)/,\n\
	rmsie = /(msie) ([\\w.]+)/,\n\
	rmozilla = /(mozilla)(?:.*? rv:([\\w.]+))?/,\n\
\n\
	// Matches dashed string for camelizing\n\
	rdashAlpha = /-([a-z]|[0-9])/ig,\n\
	rmsPrefix = /^-ms-/,\n\
\n\
	// Used by jQuery.camelCase as callback to replace()\n\
	fcamelCase = function( all, letter ) {\n\
		return ( letter + \"\" ).toUpperCase();\n\
	},\n\
\n\
	// Keep a UserAgent string for use with jQuery.browser\n\
	userAgent = navigator.userAgent,\n\
\n\
	// For matching the engine and version of the browser\n\
	browserMatch,\n\
\n\
	// The deferred used on DOM ready\n\
	readyList,\n\
\n\
	// The ready event handler\n\
	DOMContentLoaded,\n\
\n\
	// Save a reference to some core methods\n\
	toString = Object.prototype.toString,\n\
	hasOwn = Object.prototype.hasOwnProperty,\n\
	push = Array.prototype.push,\n\
	slice = Array.prototype.slice,\n\
	trim = String.prototype.trim,\n\
	indexOf = Array.prototype.indexOf,\n\
\n\
	// [[Class]] -> type pairs\n\
	class2type = {};\n\
\n\
jQuery.fn = jQuery.prototype = {\n\
	constructor: jQuery,\n\
	init: function( selector, context, rootjQuery ) {\n\
		var match, elem, ret, doc;\n\
\n\
		// Handle $(\"\"), $(null), or $(undefined)\n\
		if ( !selector ) {\n\
			return this;\n\
		}\n\
\n\
		// Handle $(DOMElement)\n\
		if ( selector.nodeType ) {\n\
			this.context = this[0] = selector;\n\
			this.length = 1;\n\
			return this;\n\
		}\n\
\n\
		// The body element only exists once, optimize finding it\n\
		if ( selector === \"body\" && !context && document.body ) {\n\
			this.context = document;\n\
			this[0] = document.body;\n\
			this.selector = selector;\n\
			this.length = 1;\n\
			return this;\n\
		}\n\
\n\
		// Handle HTML strings\n\
		if ( typeof selector === \"string\" ) {\n\
			// Are we dealing with HTML string or an ID?\n\
			if ( selector.charAt(0) === \"<\" && selector.charAt( selector.length - 1 ) === \">\" && selector.length >= 3 ) {\n\
				// Assume that strings that start and end with <> are HTML and skip the regex check\n\
				match = [ null, selector, null ];\n\
\n\
			} else {\n\
				match = quickExpr.exec( selector );\n\
			}\n\
\n\
			// Verify a match, and that no context was specified for #id\n\
			if ( match && (match[1] || !context) ) {\n\
\n\
				// HANDLE: $(html) -> $(array)\n\
				if ( match[1] ) {\n\
					context = context instanceof jQuery ? context[0] : context;\n\
					doc = (context ? context.ownerDocument || context : document);\n\
\n\
					// If a single string is passed in and it's a single tag\n\
					// just do a createElement and skip the rest\n\
					ret = rsingleTag.exec( selector );\n\
\n\
					if ( ret ) {\n\
						if ( jQuery.isPlainObject( context ) ) {\n\
							selector = [ document.createElement( ret[1] ) ];\n\
							jQuery.fn.attr.call( selector, context, true );\n\
\n\
						} else {\n\
							selector = [ doc.createElement( ret[1] ) ];\n\
						}\n\
\n\
					} else {\n\
						ret = jQuery.buildFragment( [ match[1] ], [ doc ] );\n\
						selector = (ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment).childNodes;\n\
					}\n\
\n\
					return jQuery.merge( this, selector );\n\
\n\
				// HANDLE: $(\"#id\")\n\
				} else {\n\
					elem = document.getElementById( match[2] );\n\
\n\
					// Check parentNode to catch when Blackberry 4.6 returns\n\
					// nodes that are no longer in the document #6963\n\
					if ( elem && elem.parentNode ) {\n\
						// Handle the case where IE and Opera return items\n\
						// by name instead of ID\n\
						if ( elem.id !== match[2] ) {\n\
							return rootjQuery.find( selector );\n\
						}\n\
\n\
						// Otherwise, we inject the element directly into the jQuery object\n\
						this.length = 1;\n\
						this[0] = elem;\n\
					}\n\
\n\
					this.context = document;\n\
					this.selector = selector;\n\
					return this;\n\
				}\n\
\n\
			// HANDLE: $(expr, $(...))\n\
			} else if ( !context || context.jquery ) {\n\
				return (context || rootjQuery).find( selector );\n\
\n\
			// HANDLE: $(expr, context)\n\
			// (which is just equivalent to: $(context).find(expr)\n\
			} else {\n\
				return this.constructor( context ).find( selector );\n\
			}\n\
\n\
		// HANDLE: $(function)\n\
		// Shortcut for document ready\n\
		} else if ( jQuery.isFunction( selector ) ) {\n\
			return rootjQuery.ready( selector );\n\
		}\n\
\n\
		if (selector.selector !== undefined) {\n\
			this.selector = selector.selector;\n\
			this.context = selector.context;\n\
		}\n\
\n\
		return jQuery.makeArray( selector, this );\n\
	},\n\
\n\
	// Start with an empty selector\n\
	selector: \"\",\n\
\n\
	// The current version of jQuery being used\n\
	jquery: \"1.6.4\",\n\
\n\
	// The default length of a jQuery object is 0\n\
	length: 0,\n\
\n\
	// The number of elements contained in the matched element set\n\
	size: function() {\n\
		return this.length;\n\
	},\n\
\n\
	toArray: function() {\n\
		return slice.call( this, 0 );\n\
	},\n\
\n\
	// Get the Nth element in the matched element set OR\n\
	// Get the whole matched element set as a clean array\n\
	get: function( num ) {\n\
		return num == null ?\n\
\n\
			// Return a 'clean' array\n\
			this.toArray() :\n\
\n\
			// Return just the object\n\
			( num < 0 ? this[ this.length + num ] : this[ num ] );\n\
	},\n\
\n\
	// Take an array of elements and push it onto the stack\n\
	// (returning the new matched element set)\n\
	pushStack: function( elems, name, selector ) {\n\
		// Build a new jQuery matched element set\n\
		var ret = this.constructor();\n\
\n\
		if ( jQuery.isArray( elems ) ) {\n\
			push.apply( ret, elems );\n\
\n\
		} else {\n\
			jQuery.merge( ret, elems );\n\
		}\n\
\n\
		// Add the old object onto the stack (as a reference)\n\
		ret.prevObject = this;\n\
\n\
		ret.context = this.context;\n\
\n\
		if ( name === \"find\" ) {\n\
			ret.selector = this.selector + (this.selector ? \" \" : \"\") + selector;\n\
		} else if ( name ) {\n\
			ret.selector = this.selector + \".\" + name + \"(\" + selector + \")\";\n\
		}\n\
\n\
		// Return the newly-formed element set\n\
		return ret;\n\
	},\n\
\n\
	// Execute a callback for every element in the matched set.\n\
	// (You can seed the arguments with an array of args, but this is\n\
	// only used internally.)\n\
	each: function( callback, args ) {\n\
		return jQuery.each( this, callback, args );\n\
	},\n\
\n\
	ready: function( fn ) {\n\
		// Attach the listeners\n\
		jQuery.bindReady();\n\
\n\
		// Add the callback\n\
		readyList.done( fn );\n\
\n\
		return this;\n\
	},\n\
\n\
	eq: function( i ) {\n\
		return i === -1 ?\n\
			this.slice( i ) :\n\
			this.slice( i, +i + 1 );\n\
	},\n\
\n\
	first: function() {\n\
		return this.eq( 0 );\n\
	},\n\
\n\
	last: function() {\n\
		return this.eq( -1 );\n\
	},\n\
\n\
	slice: function() {\n\
		return this.pushStack( slice.apply( this, arguments ),\n\
			\"slice\", slice.call(arguments).join(\",\") );\n\
	},\n\
\n\
	map: function( callback ) {\n\
		return this.pushStack( jQuery.map(this, function( elem, i ) {\n\
			return callback.call( elem, i, elem );\n\
		}));\n\
	},\n\
\n\
	end: function() {\n\
		return this.prevObject || this.constructor(null);\n\
	},\n\
\n\
	// For internal use only.\n\
	// Behaves like an Array's method, not like a jQuery method.\n\
	push: push,\n\
	sort: [].sort,\n\
	splice: [].splice\n\
};\n\
\n\
// Give the init function the jQuery prototype for later instantiation\n\
jQuery.fn.init.prototype = jQuery.fn;\n\
\n\
jQuery.extend = jQuery.fn.extend = function() {\n\
	var options, name, src, copy, copyIsArray, clone,\n\
		target = arguments[0] || {},\n\
		i = 1,\n\
		length = arguments.length,\n\
		deep = false;\n\
\n\
	// Handle a deep copy situation\n\
	if ( typeof target === \"boolean\" ) {\n\
		deep = target;\n\
		target = arguments[1] || {};\n\
		// skip the boolean and the target\n\
		i = 2;\n\
	}\n\
\n\
	// Handle case when target is a string or something (possible in deep copy)\n\
	if ( typeof target !== \"object\" && !jQuery.isFunction(target) ) {\n\
		target = {};\n\
	}\n\
\n\
	// extend jQuery itself if only one argument is passed\n\
	if ( length === i ) {\n\
		target = this;\n\
		--i;\n\
	}\n\
\n\
	for ( ; i < length; i++ ) {\n\
		// Only deal with non-null/undefined values\n\
		if ( (options = arguments[ i ]) != null ) {\n\
			// Extend the base object\n\
			for ( name in options ) {\n\
				src = target[ name ];\n\
				copy = options[ name ];\n\
\n\
				// Prevent never-ending loop\n\
				if ( target === copy ) {\n\
					continue;\n\
				}\n\
\n\
				// Recurse if we're merging plain objects or arrays\n\
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {\n\
					if ( copyIsArray ) {\n\
						copyIsArray = false;\n\
						clone = src && jQuery.isArray(src) ? src : [];\n\
\n\
					} else {\n\
						clone = src && jQuery.isPlainObject(src) ? src : {};\n\
					}\n\
\n\
					// Never move original objects, clone them\n\
					target[ name ] = jQuery.extend( deep, clone, copy );\n\
\n\
				// Don't bring in undefined values\n\
				} else if ( copy !== undefined ) {\n\
					target[ name ] = copy;\n\
				}\n\
			}\n\
		}\n\
	}\n\
\n\
	// Return the modified object\n\
	return target;\n\
};\n\
\n\
jQuery.extend({\n\
	noConflict: function( deep ) {\n\
		if ( window.$ === jQuery ) {\n\
			window.$ = _$;\n\
		}\n\
\n\
		if ( deep && window.jQuery === jQuery ) {\n\
			window.jQuery = _jQuery;\n\
		}\n\
\n\
		return jQuery;\n\
	},\n\
\n\
	// Is the DOM ready to be used? Set to true once it occurs.\n\
	isReady: false,\n\
\n\
	// A counter to track how many items to wait for before\n\
	// the ready event fires. See #6781\n\
	readyWait: 1,\n\
\n\
	// Hold (or release) the ready event\n\
	holdReady: function( hold ) {\n\
		if ( hold ) {\n\
			jQuery.readyWait++;\n\
		} else {\n\
			jQuery.ready( true );\n\
		}\n\
	},\n\
\n\
	// Handle when the DOM is ready\n\
	ready: function( wait ) {\n\
		// Either a released hold or an DOMready/load event and not yet ready\n\
		if ( (wait === true && !--jQuery.readyWait) || (wait !== true && !jQuery.isReady) ) {\n\
			// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).\n\
			if ( !document.body ) {\n\
				return setTimeout( jQuer