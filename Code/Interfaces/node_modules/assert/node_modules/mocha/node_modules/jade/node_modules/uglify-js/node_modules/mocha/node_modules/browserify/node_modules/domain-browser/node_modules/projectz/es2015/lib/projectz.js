'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* @flow */
/* eslint key-spacing:0 */

// Imports
// First we need to import the libraries we require.

// Load in the file system libraries.
// [SafeFS](https://github.com/bevry/safefs) is aliased to `fsUtil` as it provides protection against a lot of the common gotchas

var _require = require('safefs');

var readdir = _require.readdir;
var readFile = _require.readFile;
var writeFile = _require.writeFile;

var _require2 = require('path');

var resolve = _require2.resolve;
var join = _require2.join;

// [CSON](https://github.com/bevry/cson) is used for loading in our configuration files

var CSON = require('cson');

// [TypeChecker](https://github.com/bevry/typechecker) is used for checking data types

var _require3 = require('typechecker');

var isString = _require3.isString;
var isObject = _require3.isObject;

// [TaskGroup](https://github.com/bevry/taskgroup) is used for bundling tasks together and waiting for their completion

var _require4 = require('taskgroup');

var TaskGroup = _require4.TaskGroup;

// [Eachr](https://github.com/bevry/eachr) lets us cycle arrays and objects easily

var eachr = require('eachr');

// [Extendr](https://github.com/bevry/extendr) gives us safe, deep, and shallow extending abilities
var extendr = require('extendr');

// Load in our other project files
var Person = require('./person.js');
var backerUtil = require('./backer-util.js');
var badgeUtil = require('./badge-util.js');
var historyUtil = require('./history-util.js');
var installUtil = require('./install-util.js');
var licenseUtil = require('./license-util.js');
var projectzUtil = require('./projectz-util.js');

// Definition
// Projects is defined as a class to ensure we can run multiple instances of it

var Projectz = function () {
	_createClass(Projectz, null, [{
		key: 'create',

		/* :: cwd:string; */
		/* :: filenamesForPackageFiles:Object; */
		/* :: dataForPackageFiles:Object; */
		/* :: dataForPackageFilesEnhanced:Object; */
		/* :: filenamesForReadmeFiles:Object; */
		/* :: dataForReadmeFiles:Object; */
		/* :: dataForReadmeFilesEnhanced:Object; */
		/* :: mergedPackageData:Object; */
		/* :: log:function; */

		// Projectz.create(opts)
		value: function create() {
			for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			return new (Function.prototype.bind.apply(this, [null].concat(args)))();
		}

		// Constructor
		// Options:
		// - `cwd` the directory that we wish to do our work on, defaults to `process.cwd()`
		// - `log` the log function to use, first argument being the log level
		// Usage:
		// - `project = require('projectz').create(opts)`
		// - `project = new (require('projectz').Projectz)(opts)`

	}]);

	function Projectz(opts /* :Object */) {
		_classCallCheck(this, Projectz);

		// The current working directory (the path) that projectz is working on
		this.cwd = opts.cwd ? resolve(opts.cwd) : process.cwd();

		// Our log function to use (logLevel, ...messages)
		this.log = opts.log || function () {};
	}

	// Reset the properties of this class


	_createClass(Projectz, [{
		key: 'reset',
		value: function reset() /* :this */{
			// The absolute paths for all the package files
			this.filenamesForPackageFiles = {
				// gets filled in with relative paths
				projectz: false,
				package: false,
				bower: false,
				component: false,
				jquery: false
			};

			// The data for each of our package files
			this.dataForPackageFiles = {};

			// The enhanced data for each of our package files
			this.dataForPackageFilesEnhanced = {};

			// The absolute paths for all the readme files
			this.filenamesForReadmeFiles = {
				// gets filled in with relative paths
				readme: false,
				history: false,
				contributing: false,
				backers: false,
				license: false
			};

			// The data for each of our readme files
			this.dataForReadmeFiles = {};

			// The enhanced data for each of our readme files
			this.dataForReadmeFilesEnhanced = {};

			// The merged data for each of our package files
			this.mergedPackageData = {};

			// Chain
			return this;
		}

		// Load
		// Load in the files we will be working with
		// Usage: `load(function (err) {})`

	}, {
		key: 'load',
		value: function load(next /* :function */) /* :this */{
			var _this = this;

			// Reset
			this.reset();

			// Create our serial task group to allot our tasks into and once it completes continue to the next handler
			var tasks = new TaskGroup().done(next);

			// Load readme and package data
			tasks.addTask('loadPaths', this.loadPaths.bind(this));

			// Merge our package data
			tasks.addTask('mergeData', this.mergeData.bind(this));

			// Fetch the latest contributors. This is after the merging as we access merged properties to be able to do this.
			tasks.addTask('loadGithubContributors', function (complete) {
				_this.loadGithubContributors(function (err) {
					if (err) _this.log('warn', 'Loading contributer data failed, continuing anyway. Here was the error:\n' + err.stack);
					complete();
				});
			});

			// Enhance our package data
			tasks.addTask('enhancePackages', this.enhancePackages.bind(this));

			// Enhance our readme data
			tasks.addTask('enhanceReadmes', this.enhanceReadmes.bind(this));

			// Finish up
			tasks.run();
			return this;
		}

		// Load Github Contributors
		// Fetch the contributors for the repo if we have it
		// Usage: `loadContributors(function (err) {})`
		/* eslint array-callback-return:0 */

	}, {
		key: 'loadGithubContributors',
		value: function loadGithubContributors(next /* :function */) /* :this */{
			var _this2 = this;

			// Prepare
			var log = this.log;

			// Check
			if (!this.mergedPackageData.github || !this.mergedPackageData.github.username || !this.mergedPackageData.github.repository) {
				log('debug', 'Skipping loading github contributors as this does not appear to be a github repository');
				next();
				return this;
			}

			// Prepare
			var githubSlug = this.mergedPackageData.github.slug;
			var githubAccessToken = process.env.GITHUB_ACCESS_TOKEN;
			var githubClientId = process.env.GITHUB_CLIENT_ID;
			var githubClientSecret = process.env.GITHUB_CLIENT_SECRET;
			var githubAuthQueryString = githubAccessToken ? 'access_token=' + githubAccessToken : githubClientId && githubClientSecret ? 'client_id=' + githubClientId + '&client_secret=' + githubClientSecret : '';
			var url = 'https://api.github.com/repos/' + githubSlug + '/contributors?per_page=100&' + githubAuthQueryString;

			// Fetch the github and package contributors for it
			log('info', 'Loading contributors for repository: ' + githubSlug);
			require('chainy-core').create().require('set feed map')
			// Fetch the repositories contributors
			.set(url).feed().action(function (data) {
				if (!data) throw new Error('No contributor data was returned, likely because this repository is new');
				if (data.message) throw new Error(data.message);
			})

			// Now lets replace the shallow member details with their full github profile details via the profile api
			.map(function (user, complete) {
				this.create().set(user.url + '?' + githubAuthQueryString).feed().action(function (data) {
					if (data.message) throw new Error(data.message);
				}).done(complete);
			})

			// Now let's turn them into people
			.map(function (user) {
				var data = {
					name: user.name,
					email: user.email,
					description: user.bio,
					company: user.company,
					location: user.location,
					homepage: user.blog,
					hireable: user.hireable,
					githubUsername: user.login,
					githubUrl: user.html_url
				};
				var person = Person.ensure(data);
				person.contributesRepository(githubSlug);
			})

			// Log
			.action(function (contributors) {
				log('info', 'Loaded ' + contributors.length + ' contributors for repository: ' + githubSlug);
				_this2.mergedPackageData.contributors = Person.contributesRepository(githubSlug);
			})

			// And return our result
			.done(next);

			// Chain
			return this;
		}

		// Load Paths
		// Load in the paths we have specified
		// Usage: `loadPaths(function (err) {})`

	}, {
		key: 'loadPaths',
		value: function loadPaths(next /* :function */) /* :this */{
			var _this3 = this;

			// Create the parallel task group and once they've all completed fire our completion callback
			var tasks = new TaskGroup().setConfig({ concurrency: 0 }).done(next);

			// Apply our determined paths for packages
			var packages = Object.keys(this.filenamesForPackageFiles);
			var readmes = Object.keys(this.filenamesForReadmeFiles);

			// Load
			tasks.addTask(function (complete) {
				readdir(_this3.cwd, function (err, files) {
					if (err) return complete(err);
					files.forEach(function (file) {
						var filePath = join(_this3.cwd, file);

						packages.forEach(function (key) {
							if (file.toLowerCase().indexOf(key) === 0) {
								(function () {
									var message = 'Reading package file: ' + filePath;
									tasks.addTask(message, function (complete) {
										_this3.log('info', message);
										CSON.parseFile(filePath, function (err, data) {
											if (err) return complete(err);
											_this3.filenamesForPackageFiles[key] = file;
											_this3.dataForPackageFiles[key] = data;
											complete(err);
										});
									});
								})();
							}
						});

						readmes.forEach(function (key) {
							if (file.toLowerCase().indexOf(key) === 0) {
								(function () {
									var message = 'Reading readme file: ' + filePath;
									tasks.addTask(message, function (complete) {
										_this3.log('info', message);
										readFile(filePath, function (err, data) {
											if (err) return complete(err);
											_this3.filenamesForReadmeFiles[key] = file;
											_this3.dataForReadmeFiles[key] = data.toString();
											complete(err);
										});
									});
								})();
							}
						});
					});
					complete();
				});
			});

			// Finish up
			tasks.run();
			return this;
		}

		// Merge Packages

	}, {
		key: 'mergeData',
		value: function mergeData(next /* :function */) /* :this */{
			// By first merging in all the package data together into the enhanced data
			extendr.extend(this.mergedPackageData, this.dataForPackageFiles.component || {}, this.dataForPackageFiles.bower || {}, this.dataForPackageFiles.jquery || {}, this.dataForPackageFiles.package || {}, this.dataForPackageFiles.projectz || {});

			// ----------------------------------
			// Validation

			// Validate badges field
			if (this.mergedPackageData.badges && !this.mergedPackageData.badges.list) {
				next(new Error('projectz: badges field must now be in the format of: {list: [], config: {}}\nSee https://github.com/bevry/badges for details.'));
				return this;
			}

			// Validate keywords field
			if (isString(this.mergedPackageData.keywords)) {
				next(new Error('projectz: keywords field must be array instead of CSV'));
				return this;
			}

			// Validate sponsors array
			if (this.mergedPackageData.sponsor) {
				next(new Error('projectz: sponsor field is deprecated, use sponsors field'));
				return this;
			}
			if (isString(this.mergedPackageData.sponsors)) {
				next(new Error('projectz: sponsors field must be array instead of CSV'));
				return this;
			}

			// Validate maintainers array
			if (this.mergedPackageData.maintainer) {
				next(new Error('projectz: maintainer field is deprecated, use maintainers field'));
				return this;
			}
			if (isString(this.mergedPackageData.maintainers)) {
				next(new Error('projectz: maintainers field must be array instead of CSV'));
				return this;
			}

			// Validate license SPDX string
			if (isObject(this.mergedPackageData.license)) {
				next(new Error('projectz: license field must now be a valid SPDX string: https://docs.npmjs.com/files/package.json#license'));
				return this;
			}
			if (isObject(this.mergedPackageData.licenses)) {
				next(new Error('projectz: licenses field is deprecated, you must now use the license field as a valid SPDX string: https://docs.npmjs.com/files/package.json#license'));
				return this;
			}

			// Validate package valuees
			for (var name in this.mergedPackageData.packages) {
				if (this.mergedPackageData.packages.hasOwnProperty(name)) {
					var value = this.mergedPackageData.packages[name];
					if (!isObject(value)) {
						next(new Error('projectz: custom package data for package ' + name + ' must be an object'));
						return this;
					}
				}
			}

			// ----------------------------------
			// Merging

			// Set some basic object defaults
			extendr.defaults(this.mergedPackageData, {
				badges: {},
				readmes: {},
				packages: {},
				repository: {},
				github: {}
				// contributors: [],
				// sponsors: [],
				// maintainers: [],
				// authors: []
			});

			// Ensure badge config
			if (!this.mergedPackageData.badges.list) this.mergedPackageData.badges.list = [];
			if (!this.mergedPackageData.badges.config) this.mergedPackageData.badges.config = {};

			// Add paths so that our helpers have access to them
			this.mergedPackageData.filenamesForPackageFiles = this.filenamesForPackageFiles;
			this.mergedPackageData.filenamesForReadmeFiles = this.filenamesForReadmeFiles;

			// Fallback some defaults on the merged object
			extendr.defaults(this.mergedPackageData, {
				// Fallback browsers field, by checking if `component` or `bower` package files exists, or if the `browser` or `jspm` fields are defined
				browsers: Boolean(this.filenamesForPackageFiles.bower || this.filenamesForPackageFiles.component || this.mergedPackageData.browser || this.mergedPackageData.jspm),

				// Fallback demo field, by scanning homepage
				demo: this.mergedPackageData.homepage,

				// Fallback title from name
				title: this.mergedPackageData.name || null
			});

			// Extract repository information
			/* eslint no-magic-numbers: 0 */
			var repo = this.mergedPackageData.repository.url || null;
			var githubMatch = (this.mergedPackageData.repository.url || this.mergedPackageData.homepage).match(/github\.com\/(.+?)(?:\.git|\/)?$/);
			var githubMatchParts = (githubMatch && githubMatch[1] || '').split('/');
			if (githubMatchParts.length === 2) {
				// Extract parts

				var _githubMatchParts = _slicedToArray(githubMatchParts, 2);

				var githubUsername = _githubMatchParts[0];
				var githubRepository = _githubMatchParts[1];

				var githubSlug = githubUsername + '/' + githubRepository;
				var githubUrl = 'https://github.com/' + githubSlug;
				var githubRepositoryUrl = githubUrl + '.git';

				// Github data
				this.mergedPackageData.github = {
					username: githubUsername,
					repository: githubRepository,
					slug: githubSlug,
					url: githubUrl,
					repositoryUrl: githubRepositoryUrl
				};
				repo = githubSlug;

				// Add github data to the badges
				this.mergedPackageData.badges.config.githubUsername = githubUsername;
				this.mergedPackageData.badges.config.githubRepository = githubRepository;
				this.mergedPackageData.badges.config.githubSlug = githubSlug;

				// Fallback fields
				extendr.defaults(this.mergedPackageData, {
					// Fallback repository field by use of repo
					repository: {
						type: 'git',
						url: 'https://github.com/' + githubSlug + '.git'
					},

					// Fallback bugs field by use of repo
					bugs: {
						url: 'https://github.com/' + githubSlug + '/issues'
					}
				});
			}

			// Add npm data to the badges
			if (this.filenamesForPackageFiles.package && this.mergedPackageData.name) {
				this.mergedPackageData.badges.config.npmPackageName = this.mergedPackageData.name;
			}

			// Enhance authors, contributors and maintainers
			if (repo) {
				// Add people to the Person singleton with their appropriate permissions
				Person.add(this.mergedPackageData.author).forEach(function (person) {
					// package author string
					person.authorsRepository(repo);
				});
				Person.add(this.mergedPackageData.authors).forEach(function (person) {
					// bower authors array
					person.authorsRepository(repo);
				});
				Person.add(this.mergedPackageData.contributors).forEach(function (person) {
					person.contributesRepository(repo);
				});
				Person.add(this.mergedPackageData.maintainers).forEach(function (person) {
					person.maintainsRepository(repo);
				});

				// Add the enhanced collections to the merged data
				this.mergedPackageData.authors = Person.authorsRepository(repo);
				this.mergedPackageData.contributors = Person.contributesRepository(repo);
				this.mergedPackageData.maintainers = Person.maintainsRepository(repo);
			} else {
				this.mergedPackageData.authors = Person.add(this.mergedPackageData.author || this.mergedPackageData.authors);
				this.mergedPackageData.contributors = Person.add(this.mergedPackageData.contributors);
				this.mergedPackageData.maintainers = Person.add(this.mergedPackageData.maintainers);
			}

			// Enhance licenses and sponsors
			this.mergedPackageData.sponsors = Person.add(this.mergedPackageData.sponsors);

			// Finish up
			next();
			return this;
		}

		// Enhance Packages

	}, {
		key: 'enhancePackages',
		value: function enhancePackages(next /* :function */) /* :this */{
			// Create the data for the `package.json` format
			this.dataForPackageFilesEnhanced.package = extendr.extend(
			// New Object
			{},

			// Old Data
			this.dataForPackageFiles.package || {},

			// Enhanced Data
			{
				name: this.mergedPackageData.name,
				version: this.mergedPackageData.version,
				license: this.mergedPackageData.license,
				description: this.mergedPackageData.description,
				keywords: this.mergedPackageData.keywords,
				author: projectzUtil.getPeopleTextArray(this.mergedPackageData.authors, { displayYears: true }).join(', '),
				maintainers: projectzUtil.getPeopleTextArray(this.mergedPackageData.maintainers),
				contributors: projectzUtil.getPeopleTextArray(this.mergedPackageData.contributors),
				bugs: this.mergedPackageData.bugs,
				engines: this.mergedPackageData.engines,
				dependencies: this.mergedPackageData.dependencies,
				devDependencies: this.mergedPackageData.devDependencies,
				main: this.mergedPackageData.main
			});

			// Explicit data
			if (this.mergedPackageData.packages.package) {
				extendr.extend(this.dataForPackageFilesEnhanced.package, this.mergedPackageData.packages.package);
			}

			// jQuery
			// Create the data for the `jquery.json` format, which is essentially exactly the same as the `package.json` format so just extend that
			this.dataForPackageFilesEnhanced.jquery = extendr.extend(
			// New Object
			{},

			// Old Data
			this.dataForPackageFiles.jquery || {},

			// Enhanced Data
			this.dataForPackageFilesEnhanced.package || {});

			// Explicit data
			if (this.mergedPackageData.packages.jquery) {
				extendr.extend(this.dataForPackageFilesEnhanced.jquery, this.mergedPackageData.packages.jquery);
			}

			// Component
			// Create the data for the `component.json` format
			this.dataForPackageFilesEnhanced.component = extendr.extend(
			// New Object
			{},

			// Old Data
			this.dataForPackageFiles.component || {},

			// Enhanced Data
			{
				name: this.mergedPackageData.name,
				version: this.mergedPackageData.version,
				license: this.mergedPackageData.license,
				description: this.mergedPackageData.description,
				keywords: this.mergedPackageData.keywords,
				demo: this.mergedPackageData.demo,
				main: this.mergedPackageData.main,
				scripts: [this.mergedPackageData.main]
			});

			// Explicit data
			if (this.mergedPackageData.packages.component) {
				extendr.extend(this.dataForPackageFilesEnhanced.component, this.mergedPackageData.packages.component);
			}

			// Bower
			// Create the data for the `bower.json` format
			this.dataForPackageFilesEnhanced.bower = extendr.extend(
			// New Object
			{},

			// Old Data
			this.dataForPackageFiles.bower || {},

			// Enhanced Data
			{
				name: this.mergedPackageData.name,
				version: this.mergedPackageData.version,
				license: this.mergedPackageData.license,
				description: this.mergedPackageData.description,
				keywords: this.mergedPackageData.keywords,
				authors: projectzUtil.getPeopleTextArray(this.mergedPackageData.authors, { displayYears: true }),
				main: this.mergedPackageData.main
			});

			// Explicit data
			if (this.mergedPackageData.packages.bower) {
				extendr.extend(this.dataForPackageFilesEnhanced.bower, this.mergedPackageData.packages.bower);
			}

			// Finish up
			next();
			return this;
		}

		// Enhance Readmes

	}, {
		key: 'enhanceReadmes',
		value: function enhanceReadmes(next /* :function */) /* :this */{
			var _this4 = this;

			var data = this.mergedPackageData;
			eachr(this.dataForReadmeFiles, function (value, name) {
				if (!value) {
					_this4.log('debug', 'Enhancing readme value: ' + name + ' â€” skipped');
					return;
				}
				value = projectzUtil.replaceSection(['TITLE', 'NAME'], value, '<h1>' + data.title + '</h1>');
				value = projectzUtil.replaceSection(['BADGES', 'BADGE'], value, badgeUtil.getBadgesSection.bind(null, data));
				value = projectzUtil.replaceSection(['DESCRIPTION'], value, data.description);
				value = projectzUtil.replaceSection(['INSTALL'], value, installUtil.getInstallInstructions.bind(null, data));
				value = projectzUtil.replaceSection(['CONTRIBUTE', 'CONTRIBUTING'], value, backerUtil.getContributeSection.bind(null, data));
				value = projectzUtil.replaceSection(['BACKERS', 'BACKER'], value, backerUtil.getBackerSection.bind(null, data));
				value = projectzUtil.replaceSection(['BACKERSFILE', 'BACKERFILE'], value, backerUtil.getBackerFile.bind(null, data));
				value = projectzUtil.replaceSection(['HISTORY', 'CHANGES', 'CHANGELOG'], value, historyUtil.getHistorySection.bind(null, data));
				value = projectzUtil.replaceSection(['LICENSE', 'LICENSES'], value, licenseUtil.getLicenseSection.bind(null, data));
				value = projectzUtil.replaceSection(['LICENSEFILE'], value, licenseUtil.getLicenseFile.bind(null, data));
				_this4.dataForReadmeFilesEnhanced[name] = projectzUtil.trim(value) + '\n';
				_this4.log('info', 'Enhanced readme value: ' + name);
				return true;
			});

			// Finish up
			next();
			return this;
		}

		// Save
		// Save the data we've loaded into the files
		// Usage: `save(function (err) {})`

	}, {
		key: 'save',
		value: function save(next /* :function */) /* :this */{
			var _this5 = this;

			// Prepare
			this.log('info', 'Writing changes...');
			var tasks = new TaskGroup().setConfig({ concurrency: 0 }).done(function (err) {
				if (err) return next(err);
				_this5.log('info', 'Wrote changes');
				return next();
			});

			// Save package files
			eachr(this.filenamesForPackageFiles, function (filename, name) {
				if (!filename || name === 'projectz') return;
				var filepath = join(_this5.cwd, filename);
				var message = 'Saving package file: ' + filepath;
				tasks.addTask(message, function (complete) {
					_this5.log('info', message);
					var data = JSON.stringify(_this5.dataForPackageFilesEnhanced[name], null, '  ') + '\n';
					writeFile(filepath, data, complete);
				});
			});

			// Safe readme files
			eachr(this.filenamesForReadmeFiles, function (filename, name) {
				if (!filename) return;
				var filepath = join(_this5.cwd, filename);
				var message = 'Saving readme file: ' + filepath;
				tasks.addTask(message, function (complete) {
					_this5.log('info', message);
					var data = _this5.dataForReadmeFilesEnhanced[name];
					writeFile(filepath, data, complete);
				});
			});

			// Finish up
			tasks.run();
			return this;
		}
	}]);

	return Projectz;
}();

// Exports


module.exports = { Projectz: Projectz };